---
title: Contact Form Suck
description: 'THe truth about contact form '
pubDate: 2025-02-17T19:00:00.000Z
draft: true
heroImage: /BlogImages/comingsoon.png
authorName: 'Abdul Rafay '
authorAvatar: /IMG-20221105-WA0007.jpg
---

**You heard the title rightâ€”Iâ€™m here to expose the reality of contact forms.**

Letâ€™s be honest: **contact forms suck**â€”and I stand by that. You might disagree, but donâ€™t worry, Iâ€™ve built multiple websites, tested different implementations, and Iâ€™m here to show you exactly why they fail.

Before we dive in, you might be wondering: *What even is a contact form? Why do they suck? Is there a way to make them better?*

### A Quick Note

> If you're using platforms like WordPress or Shopify, this might not apply to you. But if you're a developer trying to build a functional, user-friendly contact form from scratch, this post is for you.

### What is a Contact Form?

At its core, a contact form acts as a bridge between users and website owners. If a user has a question, feedback, or an issue, they can fill out the form to send a message. Typically, the form is connected to an email provider or a database, ensuring that messages reach the intended recipient.

In simple terms, a contact form helps users reach out without directly exposing an email address.

Got it! You want the **problem section** to be rewritten with better grammar while keeping the flow and storytelling intact. I'll make sure the sequence of debugging steps and errors is clear and engaging. Hereâ€™s the improved version:

***

## The Problem

Let me first explain the issue before diving into the solution. My personal site, built with **Astro**, includes a **Connect with Me** section with two contact formsâ€”one on a dedicated page and another built into the homepage. Both forms share the same logic but have completely different UI designs.

Since Astro supports both **Server-Side Rendering (SSR)** and **Static Site Generation (SSG)**, I configured my project to use SSR. This allows me to integrate interactive UI components using **React**.

To make the contact form reusable, I structured it as follows:

* **ContactForm.tsx** â†’ The UI component.
* **useContactForm.tsx** â†’ A custom hook handling form submission.
* **submit.ts** â†’ The API route handling the request.

The idea was simple: the form UI would send data to the hook, which would then call the API to submit the form. If I ever wanted to switch from **Web3Forms** to another service, I could simply change the API call without modifying the rest of my code.

Here's the sequence diagram explaining my approach:

![](/BlogImages/ssd_contactform_error.png)

Everything seemed perfectâ€”reusable, modular, and scalable. But in reality, things werenâ€™t that simple.

### The Unexpected Error

The form submissions **were reaching my email**, yet the UI kept displaying **"Server Error"**. Even the server logs showed errors, despite the **network requests returning a 200 status**. This was **weird**â€”the API was clearly working, but the UI still showed an error.

I spent days debugging. I checked the **Network tab in Chrome DevTools**, expecting to find an issue with my request. But everything looked fineâ€”status 200, no CORS errors, no missing headers. I even tested the API separately in **Postman**, but the issue persisted.

At this point, I was convinced that my **code wasn't the problem**. Maybe Web3Forms itself was causing the issue?

Then, after some modifications, a **new error appeared**:

```javascript
Web3Forms Request Failed: TypeError: fetch failed
    at node:internal/deps/undici/undici:13392:13
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)
    at async Module.POST (D:/Astro-Portfolio-Blog/src/pages/api/submit.ts:27:24)
    ...
    [cause]: ConnectTimeoutError: Connect Timeout Error (attempted address: api.web3forms.com:443, timeout: 10000ms)
```

This was a **timeout error**, meaning the request was taking too long to connect. But Web3Forms' official documentation didnâ€™t mention any timeout limits. So why was this happening?

To fix this, I decided to **handle timeouts manually** in my API by setting an explicit timeout and catching errors properly. Hereâ€™s the final version of my **submit.ts** file:

```javascript
const controller = new AbortController();
const timeout = setTimeout(() => controller.abort(), 15000);

try {
  const response = await fetch("https://api.web3forms.com/submit", {
    method: "POST",
    body: submitFormData,
    signal: controller.signal,
  });

  clearTimeout(timeout);
  const data = await response.json();

  if (!response.ok) {
    throw new Error(data?.message || "Web3Forms submission failed.");
  }

  return new Response(
    JSON.stringify({ success: true, message: "Message sent successfully!" }),
    { status: 200, headers: { "Content-Type": "application/json" } }
  );
} catch (error) {
  if (error.name === "AbortError") {
    console.error("Web3Forms Request Timed Out");
    return new Response(
      JSON.stringify({ success: false, message: "Request timed out." }),
      { status: 504, headers: { "Content-Type": "application/json" } }
    );
  }
  console.error("Web3Forms Request Failed:", error);
  return new Response(
    JSON.stringify({ success: false, message: "Failed to contact Web3Forms." }),
    { status: 500, headers: { "Content-Type": "application/json" } }
  );
}
```

### The New Issue

After implementing this, I expected everything to finally work. **But no.** A new problem arose. Even though the timeout issue was handled, **sometimes the request would still fail randomly**.

So now, the question is: **Is this an issue with Web3Forms, Astro's API routes, or something else entirely?**

This journey has been full of surprises, and Iâ€™ll go into **how I finally solved it** in the next section.

Hereâ€™s your improved section with better structure, flow, and grammar while keeping your original tone:

***

## New Service

At this point, I was done. Debugging, trying new things, rewriting code, and debugging againâ€”I needed a solution. So, I started searching for alternatives, and oh boy, I was in for another few days of torture. And no, Iâ€™m not talking about the code itselfâ€”Iâ€™m talking about the sheer number of services available for something as simple as a contact form.

From my experience, there are two ways to get a contact form working:

1. **Connecting the form to a database**
2. **Using a service that forwards form submissions to your email**

I was using **Web3Forms**, which is a great service if you have a static HTML, CSS, or JavaScript-based website. But the moment you introduce React into the mixâ€”things start breaking. And since I was using React within Astro, this became a huge headache.

### The Hunt for an Alternative

So, I went on the hunt for a new service. There are quite a few out there, but let me tell youâ€”some of them have insane pricing. Some donâ€™t even have a free tier! As a solo developer, Iâ€™m not about to drop **$10/month** just to get a contact form working.

Here are some of the services I looked into:

1. **[Formspree](https://formspree.io/)** â€“ A solid service, but no free tier. If youâ€™re running a site with high traffic, this might be worth it, but for a solo dev like me? Not so much. I tried their solution, but just like Web3Forms, it didnâ€™t work smoothly with React.

   !\[Formspree Pricing]\(https\://assets.tina.io/ca928060-14c1-452c-938e-9a1e7feaae19/BlogImages/Screenshot 2025-02-16 182018.png)

   As you can see, the pricing is steep for a small personal site. If you have a larger user base, this might work, but for me, it just wasnâ€™t feasible.
2. **[FormBold](https://formbold.com/)** â€“ Another solid option, but again, no free tier. Their pricing structure is almost identical to Formspree, which makes it just as inaccessible for small personal projects.

Many of these services are great, but from a cost perspective, they just donâ€™t make sense for someone like me. Spending **$10/month** on a contact form is simply too much, especially when the free plans donâ€™t offer useful features.

Meanwhile, Web3Forms does have a free planâ€”but unfortunately, after all my testing, I just couldnâ€™t get it to work properly with React and Astro.

## The Solution

The solution for me was quite simple. I used a plain Astro component with inline `<script>` tags for various functionalities, such as UI updates, status changes, and sending requests to the Web3Forms API. I know this isn't the most optimal solution, but I had no other choice. No matter what I tried, Web3Forms only worked reliably in static HTML and JavaScript files.

Hereâ€™s the code I wrote for the contact form:

```javascript
---
import BaseHead from "@astro/base/BaseHead.astro";
import Header from "@astro/header/Header.astro";
import Footer from "@astro/footer/Footer.astro";
import authorConfig from "@config/siteConfig/info.json";
import { featureFlags } from "@config/featureFlag/featureFlag.json";
import SpeedInsights from "@vercel/speed-insights/astro";

try {
  if (!featureFlags.showContact) {
    return Astro.redirect("/access-denied");
  }
} catch (error) {
  return Astro.redirect("/404");
}
---

<html lang="en">
  <head>
    <BaseHead
      title={`Contact Me | ${authorConfig.SiteName}`}
      description="Contact me and get in touch with me."
    />
    <SpeedInsights />
  </head>
  <body>
    <Header />
    <main>
      <h1 class="text-5xl text-center font-bold mb-6">Let's Collaborate</h1>

      <section class="flex justify-center items-center bg-[--accent-dark] px-4">
        <div
          class="w-full max-w-5xl bg-[--gray-gradient] p-10 rounded-2xl border border-[--gray] mt-6"
        >
          <form
            class="space-y-4"
            id="form"
            action="https://api.web3forms.com/submit"
          >
            <input type="hidden" name="access_key" value="29b18f36-e5a9-43e0-b896-79ccb8509f17" />

            <div>
              <label class="block text-[--text-light] mb-1" for="name">Your Name</label>
              <input
                type="text"
                id="name"
                name="name"
                class="w-full p-3 rounded-lg bg-[--gray-dark] text-[--text-light] border border-[--gray] focus:outline-none focus:ring-2 focus:ring-[--accent]"
                placeholder="John Doe"
                required
              />
            </div>

            <div>
              <label class="block text-[--text-light] mb-1" for="email">Email</label>
              <input
                type="email"
                id="email"
                name="email"
                class="w-full p-3 rounded-lg bg-[--gray-dark] text-[--text-light] border border-[--gray] focus:outline-none focus:ring-2 focus:ring-[--accent]"
                placeholder="you@example.com"
                required
              />
            </div>

            <div>
              <label class="block text-[--text-light] mb-1" for="message">Message</label>
              <textarea
                id="message"
                name="message"
                class="w-full p-3 rounded-lg bg-[--gray-dark] text-[--text-light] border border-[--gray] focus:outline-none focus:ring-2 focus:ring-[--accent]"
                rows="4"
                placeholder="Write your message..."
                required
              ></textarea>
            </div>

            <div class="h-captcha" data-captcha="true"></div>

            <button
              type="submit"
              class="w-full p-3 bg-[--accent] text-[--text-light] rounded-lg hover:bg-opacity-90 transition"
            >
              Send Message
            </button>

            <div id="result" class="hidden text-center p-3 mt-4 rounded-lg"></div>
          </form>
        </div>
      </section>
    </main>

    <Footer class="mt-auto" />

    <script is:inline>
      document.getElementById("form").addEventListener("submit", function (e) {
        const hcaptchaResponse = document.querySelector('textarea[name="h-captcha-response"]');
        if (!hcaptchaResponse || hcaptchaResponse.value === "") {
          e.preventDefault();
          alert("Please complete the hCaptcha.");
        }
      });
    </script>

    <script is:inline src="https://web3forms.com/client/script.js" async defer></script>

    <script is:inline>
      const form = document.getElementById("form");
      const result = document.getElementById("result");

      form.addEventListener("submit", function (e) {
        e.preventDefault();

        const formData = new FormData(form);
        const object = Object.fromEntries(formData);
        const json = JSON.stringify(object);

        result.className = "block bg-gray-600 text-white text-center p-3 mt-4 rounded-lg";
        result.innerHTML = "Please wait...";

        fetch("https://api.web3forms.com/submit", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Accept: "application/json",
          },
          body: json,
        })
          .then(async (response) => {
            let json = await response.json();
            if (response.status == 200) {
              result.className = "block bg-green-600 text-white text-center p-3 mt-4 rounded-lg";
              result.innerHTML = json.message;
            } else {
              result.className = "block bg-red-600 text-white text-center p-3 mt-4 rounded-lg";
              result.innerHTML = json.message;
            }
          })
          .catch((error) => {
            console.error(error);
            result.className = "block bg-red-600 text-white text-center p-3 mt-4 rounded-lg";
            result.innerHTML = "Something went wrong!";
          })
          .then(() => {
            form.reset();
            setTimeout(() => {
              result.classList.add("opacity-0", "transition-opacity", "duration-500");
              setTimeout(() => {
                result.classList.add("hidden");
                result.classList.remove("opacity-0");
              }, 500);
            }, 3000);
          });
      });
    </script>
  </body>
</html>
```

This code is fairly simple. I created a contact section with a form, where two key elements play a crucial role:

1. The `#result` element, which displays feedback messages.
2. The `hCaptcha` field, ensuring the form submission is valid.

By utilizing inline `<script>` tags within the Astro component, I ensured that these scripts are only executed when needed. While this may not be the most elegant approach, it was the only way to make Web3Forms work seamlessly in a static environment.

## Final Thoughts

Building a contact form might seem like a simple task, but when you factor in React, Astro, and the sheer number of third-party services with their limitations, things can quickly spiral into frustration.

I started with Web3Forms, which worked great for static sites but failed when React entered the equation. My search for an alternative led me to services like Formspree and FormBold, but their pricing made them unviable for a solo developer. Spending $10/month on something as basic as a contact form just didnâ€™t make sense, especially when the free plans werenâ€™t offering much value.

This whole process made me realize something: sometimes, the simplest solutions are either broken or overpriced. If you're a solo developer like me, youâ€™re either stuck with limited free options or forced to pay more than what feels reasonable for your needs.

At the end of the day, I needed a cost-effective, React-friendly contact form solution, and while my journey wasnâ€™t smooth, it was definitely an eye-opener about the challenges of integrating third-party services in a modern web stack.

For now, the hunt continues. ðŸš€

Until them 
